\documentclass[a4paper,12pt]{scrreprt}

\usepackage[italian]{babel}

\usepackage[utf8]{inputenc}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{tcolorbox}
\tcbuselibrary{theorems,minted,breakable}
\newtcbtheorem[number within=chapter]{mynote}{Nota}{%
  colback=blue!5,
  colframe=blue!35!black,
  breakable,
  fonttitle=\bfseries,
  before={\vspace{0.5cm}},
  after={\vspace{0.5cm}}}{note}
\newtcblisting{myvhdl}[1]{%
  listing only,
  minted language=vhdl,
  minted options=breaklines,
  fonttitle=\bfseries,
  breakable,
  title=#1
}
\newcommand{\BashFancyFormatLine}{%
  \def\FancyVerbFormatLine##1{\$\,##1}%
}
\newtcblisting{commandshell}{%
  colback=black,
  colupper=white,
  breakable,
  colframe=yellow!75!black,
  listing only,
  minted options={formatcom=\BashFancyFormatLine},
  minted language=bash}

\usepackage{hyperref}

\usepackage{courier}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
}

\title{Il Processore Mic-1 \\
  \ \\
  \large Dispensa didattica del corso di\\
  Architettura dei Sistemi di Elaborazione}
\author{Prof.\ Nicola Mazzocca \\
  Ing.\ Alberto Moriconi}
\date{}

\begin{document}
\maketitle

\chapter{Il Livello Microarchitetturale}

Il processore Mic-1 è un utile esempio didattico, presentato in~\cite{tanenbaum}
per due scopi principali:
\begin{enumerate}
  \item mostrare come, usando elementi logici di base come quelli già studiati
  nel corso, sia possibile realizzare una microarchitettura che implementi un
  semplice set di istruzioni;
  \item mostrare come anche la realizzazione di un sistema apparentemente
  complesso come un processore si riduca in realtà alla progettazione di
  un'unità operativa e di un'unità di controllo, e del modo in cui devono
  comunicare.
\end{enumerate}

In particolare, il set di istruzioni implementato dal Mic-1 è un sottoinsieme di
quello della Java Virtual Machine, denominato \textbf{IJVM} in quanto opera
unicamente sugli interi.

Una particolarità di questo processore è quella di non disporre di registri
generali; la sua architettura è infatti detta \textit{a stack}, in quanto le sue
istruzioni aritmetiche e logiche non hanno operandi espliciti, ma li prelevano
da una struttura \textit{last-in-first-out} allocata nella memoria principale,
su cui devono essere posti in precedenza.

\medskip

Consideriamo ad esempio l'esecuzione dell'operazione di somma e assegnazione

\begin{tcblisting}{listing only}
  a1 = a2 + a3
\end{tcblisting}

che è tradotta in linguaggio assembly IJVM come

\begin{tcblisting}{listing only}
  ILOAD a2
  ILOAD a3
  IADD
  ISTORE a1
\end{tcblisting}

Lo stato dello stack durante l'esecuzione evolve come in
fig.~\ref{fig:stack_add}; inizialmente, le locazioni di memoria \lstinline{a2} e
\lstinline{a3} contengono gli operandi, mentre la locazione \lstinline{a1} è non
inizializzata; dunque:
\renewcommand{\labelenumi}{(\alph{enumi})}
\begin{enumerate}
  \item la prima istruzione \lstinline{ILOAD} legge il contenuto della locazione
  di memoria \lstinline{a2} e ne esegue il push su stack;
  \item la seconda istruzione \lstinline{ILOAD} legge il contenuto della
  locazione di memoria \lstinline{a3} e ne esegue il push su stack;
  \item l'istruzione \lstinline{IADD} esegue il pop dei due elementi in cima
  allo stack e il push della loro somma;
  \item l'istruzione \lstinline{ISTORE} esegue il pop della somma e lo scrive in
  memoria alla locazione \lstinline{a1}.
\end{enumerate}
\renewcommand{\labelenumi}{\arabic{enumi}.}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{stack_add.png}
  \caption{Evoluzione dello stack durante le operazioni di somma e
    assegnazione}\label{fig:stack_add}
\end{figure}

Supponiamo che il processore si trovi al passo (c) e debba eseguire l'istruzione
\lstinline{IADD}; per farlo deve, in prima analisi:
\begin{enumerate}
  \item eseguire un primo accesso in memoria, per prelevare il primo operando;
  \item eseguire un secondo accesso in memoria, per prelevare il secondo
  operando;
  \item sommare i due operandi;
  \item eseguire un terzo accesso in memoria, per scrivere il risultato.
\end{enumerate}

L'implementazione del processore Mic-1 che presentiamo è detta in \textit{logica
  microprogrammata}: ciascuna istruzione IJVM è implementata come una sequenza
di \textit{microistruzioni}, che complessivamente compongono il
\textit{microprogramma}, memorizzato in una ROM interna al processore. Per
capire come è strutturata una microistruzione e come è possibile realizzare un
microprograma che implementi un set di istruzioni, è necessario introdurre
anzitutto l'unità operativa del processore.

\section{L'Unità Operativa}
L'unità operativa del processore che intendiamo progettare comprende l'ALU, i
suoi ingressi e le sue uscite (tra cui i registri che si interfacciano con la
memoria), ed è mostrata in fig.~\ref{fig:datapath}.

\begin{figure}
  \centering
  \includegraphics[width=0.9\textwidth]{datapath.png}
  \caption{Parte operativa del processore Mic-1}\label{fig:datapath}
\end{figure}

I registri hanno dimensione di 32 bit e non sono accessibili al programmatore,
ma solo al microprogramma.

\begin{mynote}{}{}
  Quando diciamo che i registri non sono accessibili al programmatore intendiamo
  che essi non fanno parte del \textit{modello di programmazione}, i.e.~non
  vengono utilizzati esplicitamente come operandi delle istruzioni. Vengono
  invece utilizzati dal microprogramma per implementare le istruzioni stesse.
\end{mynote}

L'unità operativa dispone di due bus, indicati con \lstinline{B} e
\lstinline{C}, collegati rispettivamente al secondo ingresso e all'uscita
dell'ALU; il primo ingresso dell'ALU è invece collegato esclusivamente al
registro \lstinline{H}.

Con alcune eccezioni (i cui motivi diverranno chiari a breve), i registri
dispongono di una coppia di segnali di controllo che permettono:
\begin{itemize}
    \item di abilitare il collegamento del registro al bus \lstinline{B},
    rendendolo effettivamente l'operando \lstinline{B} dell'ALU;
    \item di abilitare la scrittura sul registro del risultato fornito dall'ALU
    sul bus \lstinline{C}.
\end{itemize}

Solo un registro può essere collegato al bus \lstinline{B} in un determinato
istante, mentre il risultato dell'ALU (i.e. il dato sul bus \lstinline{C}) può
essere scritto su più registri se necessario.

\begin{mynote}{}{}
  Il collegamento dei registri al bus \lstinline{B} può essere implementato
  usando porte tri-state o un multiplexer; nel nostro caso, useremo un
  multiplexer in quanto gli FPGA di cui facciamo uso dispongono di buffer
  tri-state esclusivamente ai pad di IO.
\end{mynote}

\subsection{L'Unità Aritmetico Logica}

L'ALU del processore Mic-1 ha due ingressi, che denominiamo \lstinline{A} e
\lstinline{B}; l'ingresso \lstinline{A} è collegato esclusivamente al registro
\lstinline{H} (holding), mentre l'ingresso \lstinline{B} è collegato al bus
omonimo, che può essere guidato dalle nove sorgenti indicate con una freccia
grigia in fig.~\ref{fig:datapath}; le sue funzioni sono controllate mediante sei
linee di controllo, che consideriamo asserite se poste a $1$:
\begin{itemize}
  \item \lstinline{F0} e \lstinline{F1} determinano l'operazione da eseguire;
  \item \lstinline{ENA} e \lstinline{ENB} abilitano singolarmente gli ingressi;
  \item \lstinline{INVA} inverte l'ingresso \lstinline{A};
  \item \lstinline{INC} incrementa di \lstinline{1} il risultato.
\end{itemize}

Non tutte le combinazioni di questi segnali sono rilevanti; alcune delle più
importanti per implementare il set di istruzioni IJVM sono riportate in
tab.~\ref{fig:alu_func}.

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{alu_func.png}
  \caption{Segnali di controllo ALU e relative funzioni}\label{fig:alu_func}
\end{figure}

A questi si aggiungono due segnali di controllo ulteriori, che eseguono lo shift
del risultato dell'ALU prima che esso venga posto sul bus \lstinline{C}:
\begin{itemize}
  \item \lstinline{SLL8} (\textit{Shift Left Logical 8 bit}) esegue lo shift a
  sinistra di 8 bit, ponendo i bit meno significativi a \lstinline{0};
  \item \lstinline{SRA1} (\textit{Shift Right Arithmetic 1 bit}) esegue lo shift
  a destra di 1 bit, con estensione del segno (i.e. il bit più significativo non
  cambia).
\end{itemize}

\begin{myvhdl}{alu.vhd}
entity alu is
  port (
    --! ALU control
    control       : in  alu_ctrl_type;
    --! ALU operand A
    operand_a     : in  reg_data_type;
    --! ALU operand B
    operand_b     : in  reg_data_type;
    --! ALU result
    sh_result     : out reg_data_type;
    --! Negative flag
    negative_flag : out std_logic;
    --! Zero flag
    zero_flag     : out std_logic
    );
end entity alu;
\end{myvhdl}

\begin{myvhdl}{common\_defs.vhd}
--! Contains common definitions for the processor design.
package common_defs is
  -- Data widths
  --! Processor register data width
  constant reg_data_width      : positive := 32;
  --! MBR register data width
  constant mbr_data_width      : positive := 8;
  --! ALU control width
  constant alu_ctrl_width      : positive := 8;

  [...]

  -- Subtypes
  --! Processor register data
  subtype reg_data_type is std_logic_vector(reg_data_width - 1 downto 0);
  --! MBR register data
  subtype mbr_data_type is std_logic_vector(mbr_data_width - 1 downto 0);
  --! ALU control type
  subtype alu_ctrl_type is std_logic_vector(alu_ctrl_width - 1 downto 0);

  [...]

end package common_defs;
\end{myvhdl}

\subsection{L'Interfaccia con la Memoria}

Il processore Mic-1 può comunicare con la memoria mediante due interfacce:
\begin{itemize}
  \item \lstinline{MAR} e \lstinline{MDR} controllano un'interfaccia
  word-addressable a 32 bit;
  \item \lstinline{PC} e \lstinline{MBR} controllano un'interfaccia
  byte-addressable a 8 bit.
\end{itemize}
In pratica questo significa che scrivendo \lstinline{0x2} nel registro
\lstinline{PC} e abilitando una lettura, il byte all'indirizzo \lstinline{0x2}
viene letto e posto negli 8 bit meno significativi del registro \lstinline{MBR};
scrivendo \lstinline{0x2} nel registro \lstinline{MAR} e abilitando una lettura,
i 4 byte \lstinline{0x8}-\lstinline{0x11} (i.e. la word di indirizzo
\lstinline{0x2}) vengono letti e posti nel registro \lstinline{MDR}.

\section{Le Microistruzioni}

Per controllare l'unità operativa del processore, presentata in fig.
\ref{fig:datapath}, sono necessari 29 segnali:
\begin{itemize}
    \item 9 segnali per controllare la scrittura dei dati dal bus \lstinline{C}
    ai registri;
    \item 9 segnali per controllare quale registro è collegato al bus
    \lstinline{B} e va in ingresso all'ALU;
    \item 2 segnali per abilitare lettura/scrittura sull'interfaccia
    \lstinline{MAR}/\lstinline{MDR};
    \item 1 segnale per abilitare il fetch sull'interfaccia
    \lstinline{PC}/\lstinline{MBR}.
\end{itemize}

Poiché al più un registro alla volta può essere collegato al registro
\lstinline{B}, non c'è bisogno di utilizzare effettivamente 9 segnali: dato che
al più uno di essi può essere asserito, le 10 configurazioni possibili possono
essere codificate su $\ceil{\log_{2}10} = 4$ bit.

I 24 segnali individuati permettono di controllare l'unità operativa per un
ciclo di clock; per completare una microistruzione, è necessario aggiungere due
campi aggiuntivi, che chiamiamo \lstinline{NEXT_ADDRESS} e \lstinline{JAM}, che
descriveremo approfonditamente quando parleremo dell'unità di controllo; per il
momento, è sufficiente sapere che sono necessari a determinare la
microistruzione da eseguire nel ciclo di clock successivo.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{mu_instr.png}
  \caption{Il formato delle microistruzioni del Mic-1}\label{fig:mu_instr}
\end{figure}

In fig.~\ref{fig:mu_instr} è presentato il formato che adotteremo per le
microistruzioni, rappresentate su 36 bit; come anticipato, ogni microistruzione
comprende i seguenti campi:
\begin{itemize}
  \item \lstinline{Addr} - Indirizzo di una potenziale prossima microistruzione;
  \item \lstinline{JAM} - Determina come è selezionata la prossima
  microistruzione;
  \item \lstinline{ALU} - Controllo dell'ALU e dello shifter;
  \item \lstinline{C} - Controlla quali registri vengono scritti dal bus
  \lstinline{C};
  \item \lstinline{Mem} - Controlla le operazioni di memoria;
  \item \lstinline{B} - Seleziona il registro connesso al bus \lstinline{B}
  (codifica in fig.~\ref{fig:mu_instr}).
\end{itemize}

\section{L'Unità di Controllo}

\chapter{Il Livello ISA}

\chapter{Installazione}

\begin{commandshell}
  apt-get install ghdl
\end{commandshell}

\begin{thebibliography}{2}
  \bibitem{tanenbaum}
  Andrew S. Tanenbaum and Todd Austin.
  \textit{Structured Computer Organization}.
  Pearson, 2013.

  \bibitem{calc}
  Gianni Conte, Antonino Mazzeo, Nicola Mazzocca and Paolo Prinetto.
  \textit{Architettura dei Calcolatori}.
  CittàStudi, 2015.
\end{thebibliography}
\end{document}
